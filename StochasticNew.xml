<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>const int MAX_ENEMIES := 700; //how many enemies will eventually get into the match
const int MAX_TURRETS := 7; //the maximum number of turrets that can be placed on the map

//map's definitions:
//RICORDARSI DI METTERE I COMMENTI ALLE QUERY
const int MAX_CELL_X := 15;
const int MIN_CELL_X := 0;
const int MAX_CELL_Y := 7;
const int MIN_CELL_Y := 0;
  
typedef struct {
    int[MIN_CELL_X,MAX_CELL_X] x;
    int[MIN_CELL_Y,MAX_CELL_Y] y;
} Cell;

const Cell turrets_board[MAX_TURRETS] := {{5,5},{8,2},{8,6},{14,2},{14,6},{2,3},{11,5}}; //feasible turrets spots

const Cell MAIN_POS := {15,4}; //MT spot
const Cell START_POS := {0,0}; //enemys starting spot

const int[25,25] MAX_PATH_LENGTH := 25; //length of the maximum path between START_POS and MAIN_POS

//configurations definitions:

typedef struct {
    int health;
} MTConfiguration;

typedef struct {
    int spawningTime;
    int speed;
    int health;
    int damage;
    bool kind; //necessary to distinguish between squares and circles
} EnemyConfiguration;

typedef struct {
    int range;
    int speed;
    int damage;
} TurretConfiguration;

const EnemyConfiguration CIRCLE := {2, 1, 10, 2, false};
const EnemyConfiguration SQUARE := {3, 3, 20, 4, true};

const TurretConfiguration BASIC := {2,2,2};
const TurretConfiguration CANNON := {1,7,5};
const TurretConfiguration SNIPER := {4,20,8};

const MTConfiguration MT := {100};

// shoot-related definitions:

const int[-1,-1] SPECIAL_ID := -1;
typedef int[SPECIAL_ID,MAX_ENEMIES-1] EnemyID_t; //"SPECIAL_ID" id is reserved
typedef int Life_t;

typedef struct {
    Cell pos; //actual position of the enemy
    int entering; //*
    bool kind; //"true" for SQUARE, "false" for CIRCLE
    bool targettable; //indicates if the enemy is targettable at the moment
} EnemyRecord;

typedef struct {
    EnemyID_t id; //id of the targetted enemy
    int damage; //damage for the targetted enemy
} TargetRecord;

EnemyRecord shoot_table[MAX_ENEMIES]; //each enemy has its record where to place the infos necessary to be targetted by turrets
TargetRecord target_record := {SPECIAL_ID,0}; //an enemy takes "damage" off its life if "target_record.id" corresponds to its id

int mt_life := MT.health; //MT can be simply modeled as a variable to decrement after a successful enemy shoot

int[0,MAX_ENEMIES] left_enemies := MAX_ENEMIES; //how many enemies are currently alive or about to spawn
int[0,MAX_ENEMIES] targettable_enemies := 0; //how many enemies are currently targettable (it can be also computed by counting the "targettable"
                                             //flags in "shoot_table", it's defined only for efficiency purposes (no need from turrets to scan
                                             //"shoot_table" to verify the presence of targettable enemies)

urgent broadcast chan SHOOT_TO_ENEMY; //sender: turret; receiver: enemy(s)
urgent broadcast chan SHOOT_TO_MT; //*

//useful procedures:

bool isValid (Cell c)
/**
    checks is the Cell "c" belongs to one of the paths through the MT
*/
    {
        if (c.y == 7)
            {
                return (c.x&gt;=7 &amp;&amp; c.x&lt;=15);
            } 
        if (c.y == 6 || c.y == 5)
            {
                return (c.x == 7 || c.x == 10 || c.x == 15);
            }
        if (c.y == 4)
            {
                return (c.x != 8 &amp;&amp; c.x != 9);
            }
        if (c.y == 3 || c.y == 2)
            {
                return (c.x == 0 || c.x == 7 || c.x == 15);
            }
        if (c.y == 1)
            {
                return (c.x == 0 || (c.x &gt;=7 &amp;&amp; c.x&lt;=15));
            }
        if (c.y == 0)
            {
                return (c.x == 0);
            }

        return (false);
    }
int dist(const Cell c1, const Cell c2)
/**
    calculates the Chebyshev distance between "c1" and "c2"
*/
    {
        int[MIN_CELL_X,MAX_CELL_X] v1=abs(c1.x - c2.x);
        int[MIN_CELL_Y,MAX_CELL_Y] v2=abs(c1.y - c2.y);

        if (v1&gt;=v2)
            return (v1);
        else
            return (v2);
    }
bool matchEnded()
/**
    checks if the match is ended
*/
    {
        return (left_enemies == 0);
    }</declaration>
	<template>
		<name>compactEnemy</name>
		<parameter>const EnemyID_t id, const int speed, int health, const int damage, const int spawningTime, const bool kind</parameter>
		<declaration>clock x; //clock to ensure that "shoot_table[id].lifeTime" is updated in one and only one time
         //for each instant after the enemy has spawned until it is dismissed

Cell pos; //enemy's current position on the map
int[0,2] chosenPath := 0; //which one of the three paths was non-deterministically chosen at spawning time

void initialize(const int[0,2] i)
/**
    procedure to call once an enemy has spawned 
*/
    {
        pos = START_POS;
        chosenPath = i;

        //shoot_table record update:
        shoot_table[id].kind = kind;
        shoot_table[id].targettable = true;
        shoot_table[id].pos = pos;
        shoot_table[id].entering = spawningTime; //*

        targettable_enemies++; //the enemy is now targettable
        
        x = 0;
    }
void shoot()
/**
    the shoot to the MT is modeled simply as a decrement of damage to the variable "mt_life"
*/
    {
        if (mt_life &gt; 0)
            mt_life = mt_life - damage;
    }
void dismiss ()
/**
    the enemy calls this procedure once its health goes to "&lt;=0" or it can leave the map after
    having shot to the MT
*/
    {
       //the enemy is dead:
       left_enemies--;
       //the enemy is no more targettable:
       shoot_table[id].targettable = false; 
       targettable_enemies--; 
    }
void takeDamage ()
/**
    the enemy calls this procedure if a turrets sends a message over "SHOOT_TO_ENEMY".
    Since it is a broadcast channel, each enemy firstly has to verify that its id corresponds to the one
    of the targetted enemy
*/
    {
        if (target_record.id == id) //if the enemy is the one targetted by the shoot
            {
                health = health - target_record.damage; //takes the damage off
                target_record.damage = 0; //resets the damage
                target_record.id = SPECIAL_ID; //reset the target
                if (health &lt;= 0) //if the eneny is dead, it leaves the map
                    {
                        dismiss();
                    }
            }
        //the procedure is called only in transitions with the guard "health&gt;0", this ensures that "dismiss()" cannot be called multiple times
    }
void next()
/**
    calculates the next position of an enemy based on the current position and
    the "chosenPath" (which is non-deterministically determined when the enemy is spawned).

    The complexity of the procedure is constant.
*/
    {  
          if (pos.x == 0)
            {
                if (pos.y &lt;=3)
                    pos.y = pos.y+1;
                else
                    if (pos.y == 4)
                        pos.x = 1;
                
                return;
            }
        if (pos.x &gt;=1 &amp;&amp; pos.x &lt;= 6)
            {
                pos.x = pos.x +1;
                return;
            }
        if (pos.x == 7)
            {
                if (pos.y == 4)
                    {
                        if (chosenPath == 0 || chosenPath == 1) //the "non-deterministic choice" now is not non-deterministic anymore since it was
                                                                //non-deterministically taken "a priori" in the initialization step
                            pos.y = pos.y + 1;
                        else
                            pos.y = pos.y - 1;
                    }
                else
                    if (pos.y == 5 || pos.y == 6)
                        pos.y = pos.y + 1;
                    else
                        if (pos.y == 3 || pos.y == 2)
                            pos.y = pos.y - 1;
                        else
                            if (pos.y == 7 || pos.y == 1)
                                pos.x = pos.x + 1;
                return;
            }
        if (pos.x &gt;= 8 &amp;&amp; pos.x &lt;= 9)
            {
                if (pos.y == 7 || pos.y == 1)
                    pos.x = pos.x + 1;
                return;
            }
        if (pos.x == 10)
            {
                if (pos.y == 7)
                    {
                        if (chosenPath == 0)
                            pos.y = pos.y - 1;
                        else
                            pos.x = pos.x + 1;
                    }
                else
                    if (pos.y == 6 || pos.y == 5)
                        pos.y = pos.y - 1;
                    else
                        if (pos.y == 1 || pos.y == 4)
                            pos.x = pos.x + 1;
                return;
            }
        if (pos.x &gt;= 11 &amp;&amp; pos.x &lt;= 14)
            {
                if (pos.y == 7 || pos.y == 1 || pos.y == 4)
                    pos.x = pos.x + 1;
                return;
            }
        if (pos.x == 15)
            {
                if (pos.y &lt; 4 &amp;&amp; pos.y &gt;= 1)
                    pos.y = pos.y + 1;
                else
                    if (pos.y &gt; 4 &amp;&amp; pos.y &lt;= 7)
                        pos.y = pos.y - 1;
                return;
            }
    }
bool canMove()
/**
    an enemy can move &lt;=&gt; it is alive and it has not already reached the MT
*/
    {
        return (pos!=MAIN_POS &amp;&amp; health&gt;0);
    }
bool readyToShoot()
/**
    an enemy is ready to shoot &lt;=&gt; it is alive and it reached the MT
*/
    {
        return (pos==MAIN_POS &amp;&amp; health&gt;0);
    }</declaration>
		<location id="id0" x="357" y="425" color="#00ff00">
			<name x="374" y="408">OnTrip</name>
			<label kind="exponentialrate" x="331" y="391">speed:10</label>
			<label kind="comments" x="-170" y="952">OnTrip:

In few words, an enemy stays in this state (in the sense that only takes self-transitions) as long as the MT
was not reached and health&gt;0. More in detail, an enemy:
-&gt; goes to Dismiss if and only if its health reaches 0 (or less);
-&gt; goes to AfterShoot if and only if it reaches the MT without being killed.
If no one of these conditions is satisfied the enemy keeps taking the self-transitions:
-&gt; in every time instant it has to update "shoot_table[id].lifeTime" (purpose of clock "z");
-&gt; every "speed" time instants it has to move of one cell with the method "next()" (and also
   updates "shoot_table[id].lifeTime" since the time instat has passed anyways);
-&gt; if a message is received on "SHOOT_TO_ENEMY" (provided that it is alive) it executes "takeDamage()"
   to process the possibly received shoot. "takeDamage()" is also responsible of calling the "dismiss()"
   method.</label>
		</location>
		<location id="id1" x="-110" y="425" color="#00ffff">
			<name x="-161" y="434">BeforeSpawn</name>
			<label kind="invariant" x="-178" y="391">x&lt;=spawningTime</label>
			<label kind="comments" x="-170" y="646">BeforeSpawn:

An enemy starts its execution from this state, where it stays for an amount of time exactly equal to "spawningTime" before leaving.

Since in this state the "shoot_table[id].targettable" is set to false, it can't be targetted by turrets.

Once the spawningTime has expired, there are three possible transition through "OnTrip" and what changes between them is simply
the value assigned to the variable "chosenPath". This is a quite efficient and visually-effective way of implementing the
non-determinism choices in the junction cells. In particular:
-&gt; 0: the choice in junction (7,4) is "up" and the choice in junction (10,7) is "down";
-&gt; 1: the choice in junction (7,4) is "up" and the choice in junction (10,7) is "right";
-&gt; 2: the choice in junction (7,4) is "down".

In other words, the path to the MT an enemy will non-deterministically take is calculate right after
the spawn and not upon arriving at a junction.</label>
		</location>
		<location id="id2" x="663" y="425" color="#ffa500">
			<name x="612" y="442">AfterShoot</name>
			<label kind="exponentialrate" x="671" y="391">speed:10</label>
			<label kind="comments" x="-161" y="1224">AfterShoot:

If the MT has been reached and the enemy is alive, it tries to shoot it (even if the MT has been already
killed) and goes in AfterShoot. In this state the behavior is really similar to the one of OnTrip but simplified:
-&gt; "shoot_table[id].lifeTime" is still continuosly updated since the enemy is still alive;
-&gt; after "speed" instants or if it is killed in the meantime (it can still be targetted), it goes to "Dismissed".</label>
		</location>
		<location id="id3" x="519" y="221" color="#ff0000">
			<name x="485" y="187">Dismissed</name>
			<label kind="comments" x="-161" y="1352">Dismissed:

It is only a well-state where the enemy arrives when there is no transition possible. We clarify that an enemy can
be stuck only in this state and no elsewhere.</label>
		</location>
		<init ref="id1"/>
		<transition id="id4">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="544" y="306">health&lt;=0</label>
		</transition>
		<transition id="id5">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="722" y="425">health&gt;0</label>
			<label kind="synchronisation" x="722" y="408">SHOOT_TO_ENEMY?</label>
			<label kind="assignment" x="722" y="442">takeDamage()</label>
			<nail x="714" y="416"/>
			<nail x="714" y="442"/>
		</transition>
		<transition id="id6">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="663" y="281">health&gt;0</label>
			<label kind="assignment" x="663" y="298">dismiss()</label>
			<nail x="655" y="281"/>
		</transition>
		<transition id="id7">
			<source ref="id0"/>
			<target ref="id3"/>
			<label kind="guard" x="391" y="306">health&lt;=0</label>
		</transition>
		<transition id="id8">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="guard" x="255" y="340">health&gt;0</label>
			<label kind="synchronisation" x="204" y="323">SHOOT_TO_ENEMY?</label>
			<label kind="assignment" x="230" y="357">takeDamage()</label>
			<nail x="349" y="374"/>
			<nail x="315" y="391"/>
		</transition>
		<transition id="id9">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="guard" x="314" y="484">canMove()</label>
			<label kind="assignment" x="314" y="510">next(),
shoot_table[id].pos=pos,
x=0</label>
			<nail x="331" y="476"/>
			<nail x="374" y="476"/>
		</transition>
		<transition id="id10">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="guard" x="43" y="459">x&gt;=spawningTime</label>
			<label kind="assignment" x="51" y="476">initialize(2)</label>
			<nail x="-51" y="459"/>
			<nail x="264" y="459"/>
		</transition>
		<transition id="id11">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="guard" x="34" y="349">x&gt;=spawningTime</label>
			<label kind="assignment" x="51" y="366">initialize(0)</label>
			<nail x="-51" y="391"/>
			<nail x="264" y="391"/>
		</transition>
		<transition id="id12">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="guard" x="34" y="400">x&gt;=spawningTime</label>
			<label kind="assignment" x="51" y="425">initialize(1)</label>
		</transition>
		<transition id="id13">
			<source ref="id0"/>
			<target ref="id2"/>
			<label kind="guard" x="442" y="400">readyToShoot()</label>
			<label kind="synchronisation" x="450" y="382">SHOOT_TO_MT!</label>
			<label kind="assignment" x="442" y="425">shoot(),x=0</label>
		</transition>
	</template>
	<template>
		<name>turret</name>
		<parameter>int id, const int range, const int speed, const int damage</parameter>
		<declaration>void shoot (const EnemyID_t targetId)
/**
    to shoot to the enemy with id "targetId"
*/
    {
        target_record.id = targetId;
        target_record.damage = damage;
    }
bool shootable()
/**
    this procedure is useful to prevent turrets from waiting in case the speed delay has expired but no enemy can be targetted.
    If a turret is ready to shoot but no enemy is found inside the shooting range, the turret keeps waiting for it and doesn't
    resets the speed timer (and consequently going into the "Wait" state).

    The complexity of the procedure is linear in the number of enemies.
*/
    {
        int[0,MAX_ENEMIES] i, cont;
        
        cont=0;
        for (i = 0 ; i&lt;MAX_ENEMIES &amp;&amp; cont&lt;targettable_enemies; i++)
            {
                if (shoot_table[i].targettable)
                    {
                        cont++;
                        if (dist(shoot_table[i].pos, turrets_board[id])&lt;=range)
                           {
                               return (true);
                           }
                    }
            }

        return (false);
    }
void target()
/**
    *
*/
    {
        bool found;
        int[0,MAX_ENEMIES] i, cont=0;
        EnemyID_t target_id;
        int[MIN_CELL_X,MAX_CELL_X] target_dist, d;
        int target_entering;

        if (targettable_enemies &gt; 0)
            {
                i = 0;
                found = false;
                while (i &lt; MAX_ENEMIES &amp;&amp; !found)
                    {
                        if (shoot_table[i].targettable &amp;&amp; dist(shoot_table[i].pos, turrets_board[id])&lt;=range)
                            {
                                found = true;
                            }
                        i++;
                    }
                if (found)
                    {
                        target_id = i-1;
                        target_dist = dist(shoot_table[i-1].pos, turrets_board[id]);
                        target_entering = shoot_table[i-1].entering;
                        cont++;
                        for (i = i ; i&lt;MAX_ENEMIES &amp;&amp; cont &lt; targettable_enemies; i++)
                            {
                                if (shoot_table[i].targettable)
                                    {
                                        cont++;
                                        d = dist(shoot_table[i].pos, turrets_board[id]);
                                        if (d &lt;target_dist)
                                            {
                                                target_id = i;
                                                target_dist = d;
                                                target_entering = shoot_table[i].entering;
                                            }
                                        else
                                            {        
                                                if (d == target_dist)
                                                    {
                                                        if (shoot_table[i].entering &gt; target_entering)
                                                            {
                                                                target_id = i;
                                                                target_entering = shoot_table[i].entering;
                                                            }
                                                        else
                                                            {
                                                                if (target_entering == shoot_table[i].entering)
                                                                    {
                                                                        if (shoot_table[i].kind)
                                                                            {
                                                                                 target_id = i;
                                                                            }
                                                                    }
                                                            }
                                                    }
                                            }
                                       }
                            }

                        shoot (target_id);
                    }
            }   
    }</declaration>
		<location id="id14" x="-459" y="-306" color="#00ff00">
			<name x="-484" y="-340">ReadyToShoot</name>
			<label kind="comments" x="-1028" y="-178">ReadyToShoot:

The turret stays in this state as long as there are no enemies to shoot otherwise, the most preffered of them
is shot with target().</label>
		</location>
		<location id="id15" x="-697" y="-306" color="#ffa500">
			<name x="-722" y="-340">Wait</name>
			<label kind="exponentialrate" x="-773" y="-297">1:speed</label>
			<label kind="comments" x="-1028" y="-85">Wait:

The turret stays in this state as long as the speed delay has not expired. Once it is, it goes to ReadyToShoot and
looks for enemies to shoot.</label>
		</location>
		<init ref="id14"/>
		<transition id="id16">
			<source ref="id15"/>
			<target ref="id14"/>
			<nail x="-698" y="-221"/>
			<nail x="-460" y="-221"/>
		</transition>
		<transition id="id17">
			<source ref="id14"/>
			<target ref="id15"/>
			<label kind="guard" x="-629" y="-348">shootable()</label>
			<label kind="synchronisation" x="-637" y="-331">SHOOT_TO_ENEMY!</label>
			<label kind="assignment" x="-612" y="-306">target()</label>
			<nail x="-578" y="-306"/>
		</transition>
	</template>
	<system>const int N_CIRCLES = 400;

circle(const int[0,N_CIRCLES-1] id) = compactEnemy(id, CIRCLE.speed, CIRCLE.health, CIRCLE.damage, (id+1)*CIRCLE.spawningTime, CIRCLE.kind);
square(const int[N_CIRCLES,MAX_ENEMIES-1] id) = compactEnemy(id, SQUARE.speed, SQUARE.health, SQUARE.damage, (id-(N_CIRCLES-1))*SQUARE.spawningTime, SQUARE.kind);

basic(const int[0,0] id) = turret(id,BASIC.range, BASIC.speed, BASIC.damage);
cannon(const int[1,4] id) = turret(id,CANNON.range, CANNON.speed, CANNON.damage);
sniper(const int[5,6] id) = turret(id,SNIPER.range, SNIPER.speed, SNIPER.damage);

system circle,square,basic,cannon,sniper;</system>
	<queries>
		<query>
			<formula>simulate[&lt;=200]{mt_life == MT.health}</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-06-25 23:30:12 +0200">
				<plot title="Simulations (1)" xaxis="time" yaxis="value">
					<series title="mt_life == MT.health" type="l" color="0xff0000" encoding="csv">0.0,1.0
96.05877978005711,1.0
96.05877978005711,0.0
200.0,0.0
					</series>
					<comment/>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=200]([](mt_life&gt;0))</formula>
			<comment/>
		</query>
	</queries>
</nta>
