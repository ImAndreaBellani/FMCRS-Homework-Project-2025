%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arsclassica Article
% LaTeX Template
% Version 1.1 (1/8/17)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Lorenzo Pantieri (http://www.lorenzopantieri.net) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
10pt, % Main document font size
a4paper, % Paper type, use 'letterpaper' for US Letter paper
oneside, % One page layout (no page indentation)
%twoside, % Two page layout (page indentation for binding and different headers)
headinclude,footinclude, % Extra spacing for the header and footer
BCOR5mm, % Binding correction
]{scrartcl}
\usepackage{enumitem}% http://ctan.org/pkg/enumitem

\newcommand\ytl[2]{
	\parbox[b]{8em}{\hfill{\color{cyan}\bfseries\sffamily #1}~$\cdots\cdots$~}\makebox[0pt][c]{$\bullet$}\vrule\quad \parbox[c]{7cm}{\vspace{7pt}\color{red!40!black!80}\raggedright\sffamily #2.\\[7pt]}\\[-3pt]}
\usepackage{tabularx}


\usepackage[]{biblatex}
\addbibresource{sample.bib}

\usepackage[pdftex,
pdfauthor={Andrea Bellani},
pdftitle={UppaalTD: a Formal Tower Defense Game (report)},
pdfsubject={Formal methods for concurrent and real-time systems},
pdfkeywords={Formal methods, concurrent systems, real-time systems, Uppaal, Politecnico di Milano},
pdfproducer={Latex with hyperref},
pdfcreator={pdflatex}]{hyperref}

\input{structure.tex} % Include the structure.tex file which specified the document structure and layout


\hyphenation{Fortran hy-phen-ation} % Specify custom hyphenation points in words with dashes where you would like hyphenation to occur, or alternatively, don't put any dashes in a word to stop hyphenation altogether

\title{\normalfont\spacedallcaps{UppaalTD: a Formal Tower Defense Game}} % The article title

\subtitle{Formal Methods for Concurrent and Real-Time Systems Homework} % Uncomment to display a subtitle

\author{\spacedlowsmallcaps{Andrea Bellani} (\href{mailto:andrea1.bellani@mail.polimi.it}{\nolinkurl{andrea1.bellani@mail.polimi.it}})}

\date{\today} % An optional date to appear under the author(s)



\begin{document}
	
	\renewcommand{\sectionmark}[1]{\markright{\spacedlowsmallcaps{#1}}}
	\lehead{\mbox{\llap{\small\thepage\kern1em\color{halfgray} \vline}\color{halfgray}\hspace{0.5em}\rightmark\hfil}}
	
	\pagestyle{scrheadings} % Enable the headers specified in this block
	
	\maketitle % Print the title/author/date block
	
	\paragraph*{Abstract}
		Uppaal is a tool for modeling, simulating and verifying real-time system as networks of timed automatons. In this report, we present our modeling and verification of the game UppaalTD (both vanilla and stochastic versions) in Uppaal. In Addition, we also present the most interesting modeling choices we discarded or adjusted in the final version of the model.
		
	\setcounter{tocdepth}{3} % Set the depth of the table of contents to show sections and subsections only
	
	\tableofcontents % Print the table of contents
	
	\listoffigures % Print the list of figures
	
	\listoftables % Print the list of tables
	
	\newpage
	
	\section{Introduction}
		\subsection{Definitions}
			\begin{itemize}
				\item \textbf{requirements} : the official specifications of UppaalTD's parameters and rules;
				\item \textbf{alive}, \textbf{targettable} or \textbf{shootable} enemy : the enemy has an health strictly greater than zero and is present on the map;
				\item \textbf{dismissed} enemy : the enemy is dead or it shot the MT and the following delay has expired;
				\item \textbf{configuration} : wave's composition and turrets configuration chosen (generalized definition from requirements one);
				\item \textbf{ending} of a wave : a wave is considered \emph{ended} when each enemy is dismissed (i.e. it can't move or shoot anymore because it has already shoot or it was killed by turrets);
				\item \textbf{winning} configuration : in Vanilla version, a configuration is winning if, by setting it, a wave of 3 circles and 3 square can never defeat the MT. In addition, we define also this terminologies (also for Vanilla version with 3 circles and 3 squares):
					\begin{itemize}
						\item \textbf{weakly-winning} configuration : a configuration that does not let MT to be defeat in at least one game execution;
						\item \textbf{strongly-winning} configuration : a configuration that does not let MT to be damaged in any game execution;
						\item \textbf{weakly-strongly-winning} configuration : a configuration that does not let MT to be damaged in at least one game execution;
					\end{itemize}
				\item \textbf{location} : a location of an Uppaal template;
				\item \textbf{state} : the entire game's state in a certain time instant (i.e. each automaton's position and each variable's or clock's value);
				\item \emph{Chebyshev distance} : given two generic $n$-dimensional points $x=(x_1 \dots x_n)$ and $y=(y_1 \dots y_n)$, their Chebyshev distance can be computed as $\max\limits_{1\leq i\leq n}\{|x_i - y_i|\}$.
			\end{itemize}					
		\subsection{Project development timeline}
			\begin{table}[h!]
				\centering
				\begin{minipage}[h!]{.65\linewidth}
					\color{gray}
					\rule{\linewidth}{1pt}
					\ytl{april 8th}{First brief analysis of the requirements}
					\ytl{april 9th}{Uppaal and homework presentation}
					\ytl{april 11th}{First definition of channels and MT's template}
					\ytl{april 26th}{First definition of enemy and turret template (still not synchronized) and shoot to MT modeled with \texttt{STMTCONTROLLER}}
					\ytl{may 1st}{Complete definition of all templates and synchronization without \texttt{STMTCONTROLLER}}
					\ytl{may 15th}{First definition of queries}
					\ytl{may 17th}{Enemy compact version}
					\ytl{may 24th}{Re-design of synchronization with clocks}
					\ytl{june 15th}{First stochastic version}
					\ytl{june 24th}{Started delivery procedures}
					\ytl{june 26th}{Started report writing}
					\ytl{july 10th}{Finished report writing}
					\bigskip
					\rule{\linewidth}{1pt}%
				\end{minipage}
				\caption{Project development timeline}
			\end{table}
		\subsection{Document structure}
			Main sections:
			\begin{enumerate}
				\item \textbf{Introduction} : sum up of our definitions for the terminologies used in the document and version history of our model;
				\item \textbf{Model description} : description of the models and focus on the most critical modeling choices;
				\item \textbf{Verification results} : detailed analysis of the queries verified;
				\item \textbf{Analysis of selected configurations} : presentation and deeper analysis of the models behaviors for some interesting configurations;
				\item \textbf{Conclusions} : resume of the conclusions obtained.
			\end{enumerate}
			Appendixes:
			\begin{enumerate}
				\item[A] \textbf{Discarded choices} : presentation of the most interesting discarded design choices and the motivations behind their rejection.
			\end{enumerate}
		\subsection{Software and machines used}
			\begin{table}[h!]
				\centering
				\begin{tabular}{lll}
					\toprule
					Usage     & Software & Versioning   \\
					\midrule
					Modeling, simulation and verification & Uppaal & 5.0.0  \\
					\addlinespace
					Report writing & TeXstudio & 4.6.3 \\
					\addlinespace
					Version  & Git & 2.40.0.windows.1  \\
					\bottomrule
				\end{tabular}
				\caption{Software used}
			\end{table}
			Each query was verified used two different machines with different performances that here we briefly describe:
			\begin{table}[h!]
				\centering
				\begin{tabularx}{\textwidth}{>{\raggedright\arraybackslash}p{2.5cm} >{\raggedright\arraybackslash}p{3.5cm} >{\raggedright\arraybackslash}p{3.5cm} >{\raggedright\arraybackslash}p{3cm} >{\raggedright\arraybackslash}p{2.5cm}}
					\toprule
					Machine name & CPU & RAM & OS & Manufacturing year\\
					\midrule
					\textbf{Machine 1} & AMD Ryzen 5 3500U (2.1 GHz)  & 8 GB (5,95 GB usable) & Windows 11 Home & 2020  \\
					\addlinespace
					\textbf{Machine 2} & 11th Gen Intel(R) Core(TM) i5-1135G7 (2.4 GHz) & 24 GB (23,7 GB usable) & Windows 11 Pro & 2021\\
					\bottomrule
				\end{tabularx}
				\caption{Machine specifications}
			\end{table}
			
			This document was written over the template Arsclassica Article (\url{https://www.latextemplates.com/template/arsclassica-article}) with few adjustments by us.
	\newpage
	\section{Model description}
		We modeled both the Vanilla and the Stochastic version of the game. In particular, we firstly modeled the Vanilla version and then proceeded to modify it to model the stochastic requirements. In this section we provide a detailed explanation of both versions and how the Stochastic one was obtained from the Vanilla one. We clarify that our main purpose in this section is to clarify and support our design choices rather then explain the technical aspect underlying the Uppaal code, which can be read from the templates comments.
		\subsection{Entities modeling (for Vanilla version)}
			\subsubsection{Map}
				There is no template that models the Map. Each enemy and each turret has a \texttt{Cell} constant/variable that represents its actual position on the map (\texttt{Cell} is simply a \texttt{struct} with two bounded integers):
				\begin{itemize}
					\item an enemy keeps its position updated while moving with the function \texttt{next}. If an enemy is outside of the map (because it has not spawned yet or it was killed) its position still has a "feasible" value but a flag prevents turrets to read it (see the following sections for more details);
					\item a turret can't change its position, it simply uses it to calculate its distance from enemies.  
				\end{itemize}
				To be clear, red paths structures are "embedded" into the function \texttt{next}. Another possibility (implemented in some of the previous versions) would have been to define a \texttt{Cell} matrix (or vectors) instead of define the entire structure as a less-readable the sequence of if-else implemented by \texttt{next}. We preferred this solution since \texttt{next} is constant in time and space however, with a more complex map, this approach could result in difficult to maintain \texttt{next} functions.
			\subsubsection{Main Tower (MT)}
				There is no template to model the Main Tower, it is simply modeled as a variable that enemies decrement in the shot. Originally, an MT template was designed (see the appendix for more details), it was removed in an attempt of optimizing the model, since we understood (after reasoning more on other more crucial design choices) that a so simple and "passive" entity like the MT does not really need to be implemented with a dedicated template.
				
				Decoupling enemy and turret in two templates is necessary to model in a proper and clear way the interleaving between these entities but MT neither needs to trigger other components nor has any non-deterministic behavior. The only one centralized aspect that a dedicated template could have implemented was controlling that MT's life is not $0$ before decreasing it, but this can be easily moved in enemy's template (before an enemy shoots, it checks that MT's life is not $0$) without loss of readability.
			\subsubsection{Enemy}
				Let's explain the design choices beyond each enemy's behavior.
				
				\begin{flushleft}
					\textbf{Spawn of an enemy}
					
					To model the fact that circles spawn "every x time units" and squares spawn "every y time units" we simply added a parameter \texttt{spawningTime} to enemy template. This parameter is simply a delay that must first elapse before an enemy can spawn on the map. By setting it (when we instantiate enemy processes) to \texttt{id$\times$s} (where \texttt{s} is the spawning time defined for that kind of enemy in the requirements), the enemy with id $0$ will spawn in the first time unit, the one with id $i$ with a slack of \texttt{s} time units and so on.
					Note that, as we explain in the communication section, enemy ids must not overlap each other, therefore, if $N$ enemies are present in the wave, and $M$ of them are circles:
					\begin{table}[h!]
						\centering
						\begin{tabular}{rcccccc}
							% Prima riga senza bordi
							& circle(0) & \dots & circle(M-1) & square(M) & \dots & square(N-1) \\
							id: & 0 & \dots & M-1 & M & \dots & N-1\\
							\texttt{spawningTime}: & 0 & \dots & 2$\times$(M-1) & 0 & \dots & 3$\times$(N-1-M) \\
						\end{tabular}
						\caption{\texttt{spawningTime} assignment (using requirements spawning times)}
					\end{table}
				\end{flushleft}
				\begin{flushleft}
					\textbf{Initialization of an enemy} (this paragraph is only to group all the aspects relative to the enemy that will be further explained)
					
					Once an enemy is spawned, it has to:
					\begin{itemize}
						\item initialize its record in the \texttt{shoot\_table} and update the counter of targetable enemies;
						\item reset the \texttt{trip\_time} clock;
						\item set \texttt{chosenPath}.
					\end{itemize}
				\end{flushleft}
				\begin{flushleft}
					\textbf{Move of an enemy}
					
					After the speed delay has expired, an enemy has to make a move. In fact, a move is simply an update of the enemy's position with the function \texttt{next} and a consequent update of the \texttt{shoot\_table} record (see the communication section).
					
					The very interesting design choice behind the move of an enemy is how a (deterministic, since Uppaal \texttt{random} is not available in symbolic simulation) function like \texttt{next} can model the non-deterministic next cell choice an enemy takes in a red paths junction. Simply, the choices an enemy will take in the junctions is non-deterministically determined "a priori" when an enemy spawns ()by calling \texttt{initialize} with different parameters):
					\begin{figure}[h!]
						\centering
						\includegraphics[width=0.65\textwidth]{ndPathChoice.png}
						\caption{Close-up of how "a priori" non-deterministic path choice is implemented in the enemy template}
					\end{figure}
					We realized that since during the game there is no event that may change the probability that an enemy takes a certain choice in a junction rather than another one, without loss of generality, these non-deterministic choices can be determined all at once by the time the enemy spawns.
					
					This simple intuition really improved the readability of the enemy template (in the project development timeline we called this new version \emph{compact enemy}) however, it can be convenient only if there are few possible choices.
					
					Note that even if there exist three possible paths, it would be incorrect to model only one transition per-path. These transitions must model the same probability of taking any "sequence of choices". In other words, the probability of taking the choice "under" in the junction (7,4) has a $0.5$ of probability to be taken, the other $0.5$ is the probability of choosing "up" and then there is a $0.5$ probability for each choice in the junction (10,7). If we want to determine these choices "a priori", it is not correct to model any possible path with a single transition, because it would lead the probability of taking any path to $\frac{1}{N}$ (where $N$ is the number of possible paths to the MT).
				\end{flushleft}
				\begin{flushleft}
					\textbf{Dismissal of an enemy}
					Once an enemy has to leave the map, it simply updates properly the \texttt{shoot\_table} record, the counter of the targetable enemies and the counter of the left enemies.
					
					A match is considered ended if the counter of left enemies is zero (i.e. all enemies spawned and leaved the map). Once the enemy is dismissed, it goes in a location where it waits that the match ends and then goes in an endless self-loop, this choice is in fact more crucial than it might seem:
					\begin{itemize}
						\item it prevents the system deadlock once the match is ended;
						\item putting a self-loop with no guard would of course prevent deadlock but it would possibly lead the starvation of other enemies (an enemy may arrive in the location and then self-looping indefinitely so other enemies could not move/shoot anymore). With the guard, this situation may happen only once all enemies are dismissed (and so they can't "starve" anymore).
					\end{itemize}
				\end{flushleft}
			\subsubsection{Turret}
				The high-level behavior of a turret (for the design of the communications see the following section) is pretty simple:
				\begin{enumerate}
					\item the turret (in the initial location) is ready to shoot to an enemy as soon as one of them gets into its shooting range (purpose of function \texttt{canShoot}). It check other enemies positions by looking into \texttt{shoot\_table};
					\item once \texttt{canShoot} returns true the transition to shoot to an enemy is enabled. If it is performed, the function \texttt{target} selects the nearest enemy in the shooting range (in case of ties it follows the requirements rules), and with \texttt{shoot} the enemy is shot by putting in the global variable \texttt{target\_record} the id of the target and the related damage;
					\item once the shot is performed the turret waits the delay and then returns in the initial location.
				\end{enumerate}
				\texttt{canShoot} and \texttt{target} are optimized to avoid useless scans of the \texttt{shoot\_table}, in particular:
				\begin{itemize}
					\item \texttt{canShoot} :
						\begin{itemize}
							\item does not selects the enemy to target but simply checks that there is at least one enemy in the shooting range (\texttt{target} has this purpose), which is average less complex;
							\item while scanning the \texttt{shoot\_table} it keeps counting how many targetable enemies are found (i.e. enemies that are alive on the map), so it can stop to scan it as soon as it recognizes that no targetable enemy can be found in the following records;
						\end{itemize}
					\item \texttt{target} :
						\begin{itemize}
							\item first \texttt{shoot\_table} is scanned to find the first targetable enemy in the shooting range. Then it is considered as the candidate enemy for the shot and the following positions are scanned to find a possibly "better" enemy to shoot;
							\item the scan is always stopped as soon as no targetable enemies can be found in the following records of \texttt{shoot\_table}.
						\end{itemize}
				\end{itemize}
				Note that the complexity of both \texttt{canShoot} and \texttt{target} is linear in the size \texttt{shoot\_table} length but it is totally independent from the size of the shooting range.
				
				Another improved that could be argued is to let \texttt{canShoot} pass the first enemy in the shooting range found to \texttt{target}, in this way it has already a candidate enemy. However, since \texttt{canShoot} is inside of a guard, it must be side-effects free, therefore it can't change a value outside of its scope.
		\subsection{Communication modeling description (for Vanilla version)}
			\subsubsection{How turrets shoot to enemies}
				Each enemy has a record in the \texttt{shoot\_table} structure that it keeps updated. This record contains all the information turrets need to identify which enemy shoot (position, time in which the enemy spawned, kind) and of course a flag to know if that enemy is present on the map.
				
				Once an enemy is targeted, the turret places on the global variable \texttt{target\_record} the id of the target and the related damage. In the meantime a message to all (targetable) enemies is sent over the broadcast channel \texttt{SHOOT\_TO\_ENEMY}, then each one checks if their id corresponds to the one of the target and if it is, they decrement their life accordingly to the damage and in case their health is now zero or below they leave the map.
				
				An important design choice is that \texttt{SHOOT\_TO\_ENEMY} is an urgent channel. In our vision of the game, when a turret can shoot, time can't elapse. This does not avoid situations where the delay of an enemy is fully elapsed but the move was not performed and the move is performed while the "urgent" transition is enabled by a turret (because in this case the delay has already fully elapsed, so this update does not concern time) but avoids situations where a turret is ready to shoot and it is completely ignored progress of time. In other words, a shot to an enemy must be performed in the same time unit where it is "calculated". We remark that this design choice is not a definition of priority, since the shot to an enemy is not preferred to the other transitions.
			\subsubsection{How enemies shoot to the MT}
				Since there is no template for the MT, there is apparently no need to use define a channel to "synchronize" the shot since it is nothing more than a decrement of a global variable. However, we still designed an urgent broadcast channel to guarantee the once an enemy can shoot to the MT time can't elapse (the same reason why \texttt{SHOOT\_TO\_ENEMY} is urgent). If we want to make the shot "urgent" is necessary to define the channel as broadcast otherwise, since there is no entity that "receives" that message, a deadlock would happen if an enemy wants to shoot (the enemy is blocked because no entity can receive the message and since it is urgent it blocks the time all other available enemies).
		\subsection{Enrichment of Vanilla model with stochastic features}
			To model the stochastic features there are no big change from the Vanilla model but crucial:
			\begin{itemize}
				\item enemy move/after shot delay : it is no more modeled as with a clock but with a simple self-transition (which guard of course does not involve clocks) and \texttt{OnTrip} has \texttt{rate of exponential} set to \texttt{speed:10}. In this way the probability of leaving from the state with the self-transition determines the delay before an enemy's move. The same design is applied to the "after shot" delay);
				\item turret after shot delay : it is modified with the same principle of the enemy move/after shoot delay (clock is no more used and the rate of exponential is set);
				\item self-loop in \texttt{Dismissed} : [SPIEGARE COME MAI DAVVERO E' STATO RIMOSSO, DATO CHE NON CREDO NON SIA CONCESSO AVERE NESSUNO STATO SENZA INVARIANTI E SENZA RATE OF EXPONENTIAL].
			\end{itemize}
			The only delay that is still implemented as a "non-probabilistic" delay is the one related to the spawning time.
			
			Note that there was no change in communication channels since all of them were broadcast also in the Vanilla version (stochastic model can only use broadcast channels) and the motivations behind making them \texttt{urgent} are independent from the stochastic nature of the model.
	\section{Verification results}
		\subsection{Vanilla model verification}
			\subsubsection{Verification without turrets}
				To verify the requested query we wrote the following Uppaal queries:
				\begin{table}[h!]
					\centering
					\begin{tabularx}{\textwidth}{||c|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X||}
						\hline
						 & Verified properties & Result [T/F] & Verification time on Machine 1 [s] & Verification time on Machine 2 [s] & Average maximum past-waiting list load \\
						\hline
						Q1 & I & T& & & \\ \hline
						Q2 & II & T& & & \\ \hline
						Q3 & III, IV & T& & & \\ \hline
						Q4 & V & T& & & \\
						\hline
					\end{tabularx}
					\caption{Queries without turrets overview}
				\end{table}
				Q1 must verify that the system never reaches a deadlock state, our query is then simply:
				\begin{center}
					[METTERE QUERY IN TCTL]
				\end{center}
				Originally, this query aimed only to verify deadlock avoidance only when the match is not ended. In fact, our model can still verify this query if we remove the self-loop on \texttt{Dismissed}. Informally, we can also argue that no deadlocks can happen even in this way: all enemies will eventually become \texttt{Dismissed} all together. Since once all enemies are \texttt{Dismissed} they start the to indefinitely take the self-loop:
				\begin{center}
					[MAGARI METTERE ANCHE QUESTA QUERY IN TCTL]
				\end{center}
				
				Q2 aims to verify that all enemies can reach the MT spot:
				\begin{center}
					contenuto...
				\end{center}
				We interpreted "can reach" in the sense that in any possible path all enemies will reach the MT, this is the reason way this query is not stated with "E...".
				
				Another important motivation behind this formulation is that this query in reality verifies that exists state in any possible path where all enemy have their position in the MT spot all together. This condition is easy to guarantee in our model since the dismissal of an enemy keeps \texttt{pos} to the last value it had right before the dismissal. It is like we are "freezing" in the \texttt{pos} the fact that the enemy reached the MT spot, but at the end the model will permit to any enemy to reach the MT spot.
				
				Q3 verifies both that each circle and each square satisfy the time constraint:
				\begin{center}
					[METTERE QUERY IN TCTL]
				\end{center}
				Simply once an enemy is \texttt{OnTrip} and reaches the MT spot, it must have satisfied the time constraint for its kind. \texttt{trip\_time} is a classic clock that counts the time units passed from the initialization (i.e. the time unit when the enemy spawned).
				
				Note that this query would not be satisfied in this form if \texttt{SHOOT\_TO\_MT} was not \texttt{urgent}, since this property imposes that time (and so also \texttt{trip\_time}) can't progress as long as the MT spot in reached in \texttt{OnTrip}.
				
				Q4 is probably the most intuitive query:
				\begin{center}
					[METTERE QUERY IN TCTL]
				\end{center}
				In any state of any possible path, if an enemy is targetable it must be on a red spot.
				
				Note that since \texttt{pos} is by default \texttt{{0,0}} before spawning and it is kept to the MT spot once it is reached, even if an enemy is not targetable anymore it will anyway be in a red spot. We put this restriction to the "query scope" because there is no need to check \texttt{pos} if an enemy is not present on the map. 
			\subsubsection{Verification with turrets}
				To verify the requested query we wrote the following Uppaal queries:
				\begin{table}[h!]
					\centering
					\begin{tabularx}{\textwidth}{||c|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X||}
						\hline
						& Verified properties & Result [T/F] & Verification time on Machine 1 [s] & Verification time on Machine 2 [s] & Average maximum past-waiting list load \\
						\hline
						Q1 & VII & T & & & \\ \hline
						Q5 & VI & T & & &  \\
						\hline
					\end{tabularx}
					\caption{Queries with turrets overview}
				\end{table}
				
				Q1 is used also for verifying VII since the total absence of deadlocks, in symbolic simulation, can be stated by means of the keyword \texttt{deadlock}.
				
				Since we defined a "winning" configuration as a configuration that can never let the MT to be defeated by a wave of six (three circles and three squares) enemies, a query that is true if and only if a configuration is winning is:
				\begin{center}
					mettere query in TCTL
				\end{center}
				If the MT is defeated in at least one state of one path, the query will not be satisfied (with the configuration chosen).
		\subsection{Stochastic model verification}
	\section{Analysis of selected configurations}
		\subsection{Vanilla version}
			We further analyzed the default configuration with turrets and four more configurations:
			\begin{figure}[h!]
				\centering
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{configs/vanilla/DownFromCannons.png}
					\caption{\emph{DownFromCannons} configuration}
				\end{minipage}
				\begin{minipage}{.5\textwidth}
					\centering
					\includegraphics[width=\linewidth]{configs/vanilla/DownFromSnipers.png}
					\caption{\emph{DownFromSnipers} configuration}
				\end{minipage}
			\end{figure}
			\begin{figure}[h!]
				\centering
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{configs/vanilla/Cannonphobia.png}
					\caption{\emph{Cannonphobia} configuration}
				\end{minipage}
				\begin{minipage}{.5\textwidth}
					\centering
					\includegraphics[width=\linewidth]{configs/vanilla/Sniperphobia.png}
					\caption{\emph{Sniperphobia} configuration}
				\end{minipage}
			\end{figure}
			\begin{figure}[h!]
				\centering
				\centering
				\includegraphics[width=.6\linewidth]{configs/vanilla/Default.png}
				\caption{Default configuration}
			\end{figure}
			First we analyzed if they are winning and of which kind:
			\begin{table}[h!]
				\centering
				\begin{tabularx}{\textwidth}{||X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X||}
					\hline
					& Winning [T/F] & Weakly-winning [T/F] & Strongly-winning [T/F] & Weakly-strongly-winning [T/F] \\
					\hline
					Default 		& T & T & F & T \\ \hline
					DownFromCannons & F & T & F & T \\ \hline
					DownFromSnipers & F & T & F & T \\ \hline
					Cannonphobia 	& T & T & F & T \\ \hline
					Sniperphobia 	& T & T & T & T \\ \hline
				\end{tabularx}
				\caption{Vanilla chosen configurations winning overview}
			\end{table}
			
			Then (mainly to strain more the model and to explore the Uppaal query syntax), we also wanted to define these metrics to evaluate the "strength" of a configuration (we assume that, like in Uppaal, a boolean predicate is evaluated as $1$ if it is \emph{true}, $0$ otherwise):
			\begin{itemize}
				\item \emph{ADMT} (\emph{Average Distance from MT}) : it is the minimum average distance that enemies can have to the MT:
				\begin{center}
					$ADMT:=\min\{\frac{\sum_{e:Enemy} dist(e.pos,MAIN\_POS)}{MAX\_ENEMIES}\}$
				\end{center}
				\item \emph{SE} (\emph{Survived Enemies}) : it is the maximum number of enemies that still were never be killed throughout the whole match:
				\begin{center}
					$SE:=\max\limits_{matchEnded}\{\sum_{e:Enemy} (e.health>0)\}$
				\end{center}
				\item \emph{CUPE} (\emph{Completed Upper Paths Enemies}) : it is the maximum number of enemies that reached the MT by choosing "up" in the junction \{7,4\}:
				\begin{center}
					$CUPE:=\max\{\sum_{e:Enemy} ((e.pos == MAIN\_POS)*(e.chosenPath\neq 2))\}$
				\end{center}
				\item \emph{CLPE} (\emph{Completed Lower Paths Enemies}) : it is the maximum number of enemies that reached the MT by choosing "down" in the junction \{7,4\}:
				\begin{center}
					$CLPE:=\max\{\sum_{e:Enemy} ((e.pos == MAIN\_POS)*(e.chosenPath=2))\}$
				\end{center}
			\end{itemize}
			
			\begin{table}[h!]
				\centering
				\begin{tabular}{||l|c|c|c|c||}
					\hline
					& ADMT & SE & CUPE & CLPE \\
					\hline
					Default 		& 4 & 2 & 2 & 1 \\ \hline
					DownFromCannons & 1 & 5 & 2 & 5 \\ \hline
					DownFromSnipers & 0 & 6 & 2 & 6 \\ \hline
					Cannonphobia 	& 4 & 2 & 2 & 2 \\ \hline
					Sniperphobia 	& 7 & 0 & 0 & 0 \\ \hline
				\end{tabular}
				\caption{Vanilla chosen configurations performances}
			\end{table}
			Note that:
			\begin{itemize}
				\item strongly-winning configurations have a SE of 0 (if an enemy has survived it means that it shot the MT, and so the configuration can't be strongly-winning);
				\item weakly-winning configurations are likely to have lower ADMT since at least of the execution where the MT is defeat, an amount of enemies must arrive at in the MT spot and for the same reason, they are more likely to have higher SE;
				\item is quite unlikely to have a configuration where $CUPE>SE$ or $CLPE>SE$, because enemies that reached the MT are really likely to survive (and they will survive of course in configurations like Cannonphobia where the MT spot is outside of any shooting range).
			\end{itemize}
			At the end, to judge a configuration we may look for the one with an higher ADMT and a lower SE. CUPE and CLPE and are not better than SE to compare configurations, we defined them to demonstrate that configurations that do not cover parts of the map are more like to see (from the MT spot point of view) enemies coming from those parts. Indeed, DownFromCannons and DownFromSnipers have $CUPE\leq CLPE$ since they cover more the higher paths of the map, while more "uniform" configurations tend to have $CUPE=CLPE=SE$ (that holds also from a probabilistic point of view; see the section dedicated to the spawn strategy).
		\subsection{Stochastic version}

	\section{Conclusions}

	\newpage
	\appendix
	\section{Discarded choices}
		We wanted to write this additional section mainly to better clarify the reasons behind our final design choices. Nonetheless, we would like to clarify that our design choices are what we believed to be more efficient and adequate for our interpretation of the game, so some of the discarded can possibly be the best ones in other contexts or with different requirements and also for this reason we wanted to state them in the report.
		\subsection{MT template}
			Originally, a template for MT was designed. It was, for its simplicity, the very first one to be designed (\texttt{decDamage} decreases MT's life by the value set in a global variable from the firing enemy):
			
			\begin{figure}[h!]
				\centering
				\includegraphics[width=0.5\textwidth]{MT_Template.png}
				\caption{Original MT's template}
			\end{figure}
		\subsection{Hard-coded enemies paths}
			The very first enemy version used the concept of \texttt{next} but there was no idea on how to model the non-deterministic moves (unless using function \texttt{random}, which is not available in symbolic simulation). The only idea was to hard-code vectors of cells representing each straight red path on the map and enemies template would have chosen between them non-deterministically with transitions (once an enemy arrives in the last cell of a path, then it will start to follow non-deterministically one of the "next paths"):
			
			\begin{figure}[h!]
				\centering
				\includegraphics[width=0.65\textwidth]{ENEMIES_PATHS.png}
				\caption{Original non-deterministic path choices example}
			\end{figure}
		\subsection{Quadratic enemies scanning strategy}
			The very first turret version used to look for enemies to shoot in this way: for each $k$ from $1$ to the \texttt{range}, scan \texttt{SHOOT\_TABLE} to find all the available enemies at exactly $k$ cells of distance; then, choose the best iso-distant available enemy based on the requirements criteria. The worst-case asymptotic complexity of this procedure was $\Theta(k\times MAX\_ENEMIES)$ which was significantly worse than the one of the final version which is $\Theta(MAX\_ENEMIES)$ especially in the average case where there is no enemy inside the shooting range.
		\subsection{Locks}
			At the beginning, the first way of synchronizing entities was thought in a classical lock-unlock manner:
			\begin{figure}[h!]
				\centering
				\begin{minipage}{.5\textwidth}
					\centering
					\includegraphics[width=.9\linewidth]{enemyLock.png}
					\caption{Close-up of the enemy locking \texttt{STMT} channel}
				\end{minipage}
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=.9\linewidth]{controller.png}
					\caption{\texttt{STMTCONTROLLER} template}
				\end{minipage}
			\end{figure}
			Once an enemy reaches the MT (for the MT template please see the proper section of the appendix):
			\begin{enumerate}
				\item the enemy sends a message to \texttt{STMTCONTROLLER} and waits for its reply (more precisely, Uppaal chooses non-deterministically which one of the ready enemies can send the message to the controller);
				\item once the controller replies the enemy places in the shared variable the damage for the MT;
				\item the enemy shoots to the MT (i.e. sends a message over \texttt{STMT});
				\item the enemy sends a message to \texttt{STMTCONTROLLER} to release the "lock".
			\end{enumerate}
			We understand that this solution is:
			\begin{itemize}
				\item deadlock-free: soon or later an acquired lock will be released and soon or later a lock request will be accepted;
				\item not starvation-free: since it is not guaranteed that any enemy that requests a lock will eventually obtain it.
			\end{itemize}
			We removed this concept since we understood that a single transition that both changes the global variable and performs the shoot would have produced the same behavior, since, provided that this transition is not synchronized with other enemies, only one of them can perform it in a time instant, therefore there is no possibility that an enemy places the damage for the MT into the shared variable and before sending the shooting message another enemy changes the variable and (or not) shoots to the MT (which would clearly create an undesired behavior).
		\subsection{Lifetime counter}
			As we have seen, turrets understand that an enemy is present on the map for a shorter amount of time by looking to its spawning. This idea lets enemies to not keep a counter updated to tell the turrets that they are present on the map for tot. time units. However, this idea is relatively new in the history of the model, since at the beginning, the lifetime of an enemy used to be update in each time unit by the enemy:
			
			\begin{figure}[h!]
				\centering
				\includegraphics[width=0.5\textwidth]{lifetimeCounter.png}
				\caption{Close-up of of the lifetime counter of an enemy}
			\end{figure}
			With clock \texttt{z} at each time unit the lifetime counter would have been updated.
			
			Note that this solution was also used to verify that enemies would have reached the MT spot in no more than $\texttt{MAX\_PATH\_LENGTH}\times speed$ time units.
	\nocite{1,2,3,4,5,6,7}
	\printbibliography
\end{document}