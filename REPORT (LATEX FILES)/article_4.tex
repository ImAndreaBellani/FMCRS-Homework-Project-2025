%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arsclassica Article
% LaTeX Template
% Version 1.1 (1/8/17)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Lorenzo Pantieri (http://www.lorenzopantieri.net) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
10pt, % Main document font size
a4paper, % Paper type, use 'letterpaper' for US Letter paper
oneside, % One page layout (no page indentation)
%twoside, % Two page layout (page indentation for binding and different headers)
headinclude,footinclude, % Extra spacing for the header and footer
BCOR5mm, % Binding correction
]{scrartcl}
\usepackage{enumitem}% http://ctan.org/pkg/enumitem

\newcommand\ytl[2]{
	\parbox[b]{8em}{\hfill{\color{cyan}\bfseries\sffamily #1}~$\cdots\cdots$~}\makebox[0pt][c]{$\bullet$}\vrule\quad \parbox[c]{10cm}{\vspace{7pt}\color{red!40!black!80}\raggedright\sffamily #2.\\[7pt]}\\[-3pt]}
\usepackage{tabularx}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[backend=biber]{biblatex}
\addbibresource{sample.bib}


\usepackage[pdftex,
pdfauthor={Andrea Bellani},
pdftitle={UppaalTD: a Formal Tower Defense Game (report)},
pdfsubject={Formal methods for concurrent and real-time systems},
pdfkeywords={Formal methods, concurrent systems, real-time systems, Uppaal, Politecnico di Milano},
pdfproducer={Latex with hyperref},
pdfcreator={pdflatex}]{hyperref}
\usepackage{float}
\input{structure.tex} % Include the structure.tex file which specified the document structure and layout


\hyphenation{Fortran hy-phen-ation} % Specify custom hyphenation points in words with dashes where you would like hyphenation to occur, or alternatively, don't put any dashes in a word to stop hyphenation altogether

\title{\normalfont\spacedallcaps{UppaalTD: a Formal Tower Defense Game}} % The article title

\subtitle{Formal Methods for Concurrent and Real-Time Systems Homework} % Uncomment to display a subtitle

\author{\spacedlowsmallcaps{Andrea Bellani} (\href{mailto:andrea1.bellani@mail.polimi.it}{\nolinkurl{andrea1.bellani@mail.polimi.it}})}

\date{\today} % An optional date to appear under the author(s)



\begin{document}
	\renewcommand{\sectionmark}[1]{\markright{\spacedlowsmallcaps{#1}}}
	\lehead{\mbox{\llap{\small\thepage\kern1em\color{halfgray} \vline}\color{halfgray}\hspace{0.5em}\rightmark\hfil}}
	
	\pagestyle{scrheadings} % Enable the headers specified in this block
	
	\maketitle % Print the title/author/date block
	
	\paragraph*{Abstract}
		Uppaal is a tool for modeling, simulating and verifying real-time system as networks of timed automatons. In this report, we present our modeling and verification of the game UppaalTD (both vanilla and stochastic versions) in Uppaal. In Addition, we analyze the model behavior with selected configurations and define metrics to compare them.
		
	\setcounter{tocdepth}{3} % Set the depth of the table of contents to show sections and subsections only
	
	\tableofcontents % Print the table of contents
	
	\listoffigures % Print the list of figures
	
	\listoftables % Print the list of tables
	
	\newpage
	
	\section{Introduction}
		\subsection{Definitions}
			\begin{itemize}
				\item \textbf{requirements} : the official specifications of UppaalTD's parameters and rules;
				\item \textbf{alive}, \textbf{targettable} or \textbf{shootable} enemy : the enemy has an health strictly greater than zero and is present on the map;
				\item \textbf{dismissed} enemy : the enemy is dead or it shot the MT and the following delay has expired;
				\item \textbf{ending} of a wave : a wave is considered \emph{ended} when each enemy is dismissed (i.e. it can't move or shoot anymore because it has already shoot or it was killed by turrets);
				\item \textbf{winning} configuration : in Vanilla version, a configuration is winning if, by setting it, a wave of 3 circles and 3 square can never defeat the MT. In addition, we define also this terminologies (for Vanilla version with 3 circles and 3 squares):
					\begin{itemize}
						\item \textbf{weakly-winning} configuration : a configuration that does not let the MT to be defeated in at least one game execution;
						\item \textbf{strongly-winning} configuration : a configuration that does not let the MT to be damaged in any game execution;
						\item \textbf{weakly-strongly-winning} configuration : a configuration that does not let the MT to be damaged in at least one game execution;
					\end{itemize}
				\item \textbf{location} : a location of an Uppaal template;
				\item \textbf{state} : the entire game's state in a certain time instant (i.e. each automaton's position and each variable's or clock's value);
				\item \emph{Chebyshev distance} : given two generic $n$-dimensional points $x=(x_1 \dots x_n)$ and $y=(y_1 \dots y_n)$, their Chebyshev distance can be computed as $\max\limits_{1\leq i\leq n}\{|x_i - y_i|\}$.
			\end{itemize}					
		\subsection{Project development timeline}
			\begin{table}[h!]
				\centering
				\begin{minipage}[h!]{.8\linewidth}
					\color{gray}
					\rule{\linewidth}{1pt}
					\ytl{april 8th}{First brief analysis of the requirements}
					\ytl{april 9th}{Uppaal and homework presentation}
					\ytl{april 11th}{First definition of channels and MT's template}
					\ytl{april 26th}{First definition of enemy and turret template (still not synchronized) and shoot to MT modeled with \texttt{STMTCONTROLLER}}
					\ytl{may 1st}{Complete definition of all templates and synchronization without \texttt{STMTCONTROLLER}}
					\ytl{may 15th}{First definition of queries}
					\ytl{may 17th}{Enemy compact version}
					\ytl{may 24th}{Re-design of synchronization with clocks}
					\ytl{june 15th}{First stochastic version}
					\ytl{june 24th}{Started delivery procedures}
					\ytl{june 26th}{Started report writing}
					\ytl{july 15th}{Finished report writing}
					\bigskip
					\rule{\linewidth}{1pt}%
				\end{minipage}
				\caption{Project development timeline}
			\end{table}
		\subsection{Document structure}
			Main sections:
			\begin{enumerate}
				\item \textbf{Introduction} : sum up of our definitions for the terminologies used in the document and project development timeline;
				\item \textbf{Model description} : description of the models with focus on the most critical modeling choices;
				\item \textbf{Verification results} : detailed analysis of the queries verified;
				\item \textbf{Analysis of selected configurations} : presentation and deeper analysis of models behaviors with interesting configurations;
				\item \textbf{Conclusions} : resume of the results obtained.
			\end{enumerate}
			Appendixes:
			\begin{enumerate}
				\item[A] \textbf{Discarded choices} : presentation of the most interesting discarded design choices and the motivations behind their rejection.
			\end{enumerate}
		\subsection{Software and machines used}
			\begin{table}[h!]
				\centering
				\begin{tabular}{lll}
					\toprule
					Usage     & Software & Versioning   \\
					\midrule
					Modeling, simulation and verification & Uppaal & 5.0.0  \\
					\addlinespace
					Report writing & TeXstudio & 4.6.3 \\
					\addlinespace
					Versioning  & Git & 2.40.0.windows.1  \\
					\addlinespace
					Configurations drawing & draw.io & v28.0.4  \\
					\bottomrule
				\end{tabular}
				\caption{Software used}
			\end{table}
			Each query was verified on two different machines with different hardware and performances:
			\begin{table}[h!]
				\centering
				\begin{tabularx}{\textwidth}{>{\raggedright\arraybackslash}p{2.5cm} >{\raggedright\arraybackslash}p{3.5cm} >{\raggedright\arraybackslash}p{3.5cm} >{\raggedright\arraybackslash}p{3cm} >{\raggedright\arraybackslash}p{2.5cm}}
					\toprule
					Machine name & CPU & RAM & OS & Manufacturing year\\
					\midrule
					\textbf{Machine 1} & AMD Ryzen 5 3500U (2.1 GHz)  & 8 GB (5,95 GB usable) & Windows 11 Home & 2020  \\
					\addlinespace
					\textbf{Machine 2} & 11th Gen Intel(R) Core(TM) i5-1135G7 (2.4 GHz) & 24 GB (23,7 GB usable) & Windows 11 Pro & 2021\\
					\bottomrule
				\end{tabularx}
				\caption{Machines specifications}
			\end{table}
			
			This document was written over the template Arsclassica Article (\url{https://www.latextemplates.com/template/arsclassica-article}) with few adjustments by us.
	\newpage
	\section{Model description}
		We modeled both the Vanilla and the Stochastic version of the game. In particular, we firstly modeled the Vanilla version and then proceeded to modify it to model the stochastic requirements. In this section we provide a detailed explanation of both versions and how the Stochastic version was obtained from the Vanilla one.
		\subsection{Entities modeling (for Vanilla version)}
			\subsubsection{Map}
				There is no template that models the Map. Each enemy and each turret has a \texttt{Cell} variable that represents its actual position on the map (\texttt{Cell} is simply a \texttt{struct} with two bounded integers):
				\begin{itemize}
					\item an enemy keeps its position updated while moving with the function \texttt{next}. If an enemy is outside of the map (because it has not spawned yet or it was dimissed) its position still has a "feasible" value but a flag prevents turrets to read it (see the following sections for more details);
					\item a turret can't change its position, it simply uses it to calculate its distance from enemies.  
				\end{itemize}
				To be clear, red paths structures are "embedded" into the function \texttt{next}. Another possibility (implemented in some of the previous versions) would have been to define a \texttt{Cell} matrix (or vectors) instead of defining the entire structure as a sequence of if-else in \texttt{next}. We preferred the latter since \texttt{next} is constant in time and space however, with a more complex map, this approach could result in a too difficult to maintain solution.
			\subsubsection{Main Tower (MT)}
				There is no template that models the Main Tower, it is simply modeled as a variable that enemies decrement in the shot. Originally, an MT template was designed (see the appendix for more details), it was removed in an attempt of optimizing the model, since we understood (after reasoning more on other more crucial design choices) that a so simple and "passive" entity like the MT does not really need to be implemented with a dedicated template.
				
				Decoupling enemy and turret in two templates is necessary to model in a proper and clear way the interleaving between these entities but MT neither needs to trigger other components nor has any non-deterministic behavior. The only one centralized aspect that a dedicated template could have implemented was controlling that MT's life is not $0$ before decreasing it, but this can be easily moved in enemy's template (before an enemy shoots, it checks that MT's life is not $0$) without loss of readability.
			\subsubsection{Enemy}
				\begin{flushleft}
					\textbf{Spawn of an enemy}
					
					To model the requirement that circles spawn "every x time units" and squares spawn "every y time units" we simply added a parameter \texttt{spawningTime} to the enemy template. This parameter is simply a delay that must first elapse before an enemy can spawn on the map. By setting it (when we instantiate enemy processes) to \texttt{id$\times$s} (where \texttt{s} is the spawning time defined for that kind of enemy in the requirements), the enemy with id $0$ will spawn in the first time unit, the one with id $i$ will spawn with a delay of \texttt{s} time units and so on:
					\begin{table}[h!]
						\centering
						\begin{tabular}{rcccccc}
							% Prima riga senza bordi
							& circle(0) & \dots & circle(M-1) & square(M) & \dots & square(N-1) \\
							id: & 0 & \dots & M-1 & M & \dots & N-1\\
							\texttt{spawningTime}: & 0 & \dots & 2$\times$(M-1) & 0 & \dots & 3$\times$(N-1-M) \\
						\end{tabular}
						\caption{\texttt{spawningTime} assignment (using requirements spawning times)}
					\end{table}
				\end{flushleft}
				\begin{flushleft}
					\textbf{Initialization of an enemy} (this paragraph aims only to group all the aspects related to the enemy template that will be explained further)
					
					Once an enemy is spawned, it has to:
					\begin{itemize}
						\item initialize its record in the \texttt{shoot\_table} and update the counter of targetable enemies;
						\item reset the \texttt{trip\_time} clock;
						\item set \texttt{chosenPath}.
					\end{itemize}
				\end{flushleft}
				\begin{flushleft}
					\textbf{Move of an enemy}
					
					After the speed delay has expired, an enemy has to make a move. In fact, a move is simply an update of the enemy's position with the function \texttt{next} and a consequent update of the \texttt{shoot\_table} record (see the communication section).
					
					The very interesting design choice behind the move of an enemy is how a (deterministic, since Uppaal \texttt{random} is not available in symbolic simulation) function like \texttt{next} can model the non-deterministic next cell choice an enemy has to take in a red paths junction. Simply, the choices an enemy will take in junctions are non-deterministically determined "a priori" when an enemy spawns, by calling \texttt{initialize} with different parameters:
					\begin{figure}[h!]
						\centering
						\includegraphics[width=0.5\textwidth]{ndPathChoice.png}
						\caption{Close-up of how "a priori" non-deterministic path choice is implemented in the enemy template}
					\end{figure}
					
					We realized that since during the game there is no event that may change the probability that an enemy takes a certain choice in a junction rather than another, without loss of generality these non-deterministic choices can be determined all at once by the time the enemy spawns.
					
					This simple intuition really improved the readability of the enemy template (in the project development timeline we called this new version \emph{compact enemy}) however, it can be convenient only if there are few possible choices.
					
					Note that even if there exist three possible paths, it would be incorrect to model only one transition per-path. These transitions must model the same probability of taking any "sequence of choices". In other words, the probability of taking the choice "under" in the junction (7,4) has a $0.5$ of probability to be taken, the other $0.5$ is the probability of choosing "up" and then there is a $0.5$ probability for each choice in the junction (10,7). If we want to determine these choices "a priori", it is not correct to model any possible path with a single transition, because it would lead the probability of taking any path to $\frac{1}{N}$ (where $N$ is the number of possible paths to the MT).
				\end{flushleft}
				\begin{flushleft}
					\textbf{Dismissal of an enemy}
					
					Once an enemy has to leave the map, it simply updates properly the \texttt{shoot\_table} record, the counter of the targetable enemies and the counter of the left enemies.
					
					A match is considered ended if the counter of left enemies is zero (i.e. all enemies spawned and leaved the map for a certain reason). Once the enemy is dismissed, it goes in a location where it waits that the match ends and then goes (in the sense that a self-loop with is enabled) in an endless self-loop, this choice is in fact more crucial than it might seem:
					\begin{itemize}
						\item it prevents the system deadlock once the match is ended;
						\item putting a self-loop with no guard would of course prevent deadlocks but it would possibly lead the starvation of other entities since an enemy may arrive in the Dismissed location and then self-looping indefinitely so other entities could not move/shoot anymore, and so preventing some queries to be verified (e.g. query Q2). With the guard, this situation may happen only once all enemies are dismissed (and so no entity can "starve" anymore).
					\end{itemize}
				\end{flushleft}
			\subsubsection{Turret}
				The high-level behavior of a turret (for the design of the communications see the following section) is pretty simple:
				\begin{enumerate}
					\item the turret (in the initial location) is ready to shoot to an enemy as soon as one of them gets into its shooting range (purpose of the function \texttt{canShoot}). It checks other enemies positions by looking into \texttt{shoot\_table};
					\item once \texttt{canShoot} returns true the transition to shoot to an enemy is enabled. If it is performed, the function \texttt{target} selects the nearest enemy in the shooting range (in case of ties it follows the requirements rules), and with \texttt{shoot} the enemy is shot by putting in the global variable \texttt{target\_record} the id of the target and the related damage;
					\item once the shot is performed, the turret waits the delay and then comes back to the initial location.
				\end{enumerate}
				\texttt{canShoot} and \texttt{target} are optimized to avoid useless scans of the \texttt{shoot\_table}, in particular:
				\begin{itemize}
					\item \texttt{canShoot} :
						\begin{itemize}
							\item does not select the enemy to target but simply checks that there is at least one enemy in the shooting range (\texttt{target} has targeting purpose), which is average less complex (but not asymptotically);
							\item while scanning the \texttt{shoot\_table} it keeps counting how many targetable enemies are found (i.e. enemies that are alive on the map), so it can stop as soon as it recognizes that no targetable enemies can be found in the following records;
						\end{itemize}
					\item \texttt{target} :
						\begin{itemize}
							\item scans \texttt{shoot\_table} to find the first targetable enemy in the shooting range. It is considered as the candidate enemy for the shot and the following records are scanned to find a possibly "better" enemy to shoot;
							\item the scan is always stopped as soon as no targetable enemies can be found in the following records.
						\end{itemize}
				\end{itemize}
				Note that the complexity of both \texttt{canShoot} and \texttt{target} is linear in the \texttt{shoot\_table} length but it is totally independent of the size of the shooting range.
				
				Another improvement that could be argued is to let \texttt{canShoot} pass the first enemy in the shooting range found to \texttt{target}, in this way the latter has already a candidate enemy. However, since \texttt{canShoot} is inside a guard, it must be side-effects free, therefore it can't change a value outside of its scope.
		\subsection{Communication modeling description}
			\subsubsection{How turrets shoot to enemies}
				Each enemy has a record in the \texttt{shoot\_table} structure to keep updated. This record contains all the information turrets need to identify the enemy to shoot (i.e. position, time in which the enemy spawned and enemy's kind) and a flag to know if that enemy is present on the map.
				
				Once an enemy is targeted, the turret places on the global variable \texttt{target\_record} the id of the target and the related damage. In the meantime a message to all (targetable) enemies is sent over the broadcast channel \texttt{SHOOT\_TO\_ENEMY}, then each enemy checks if its id corresponds to the one of the target; if it is, it decrements its life accordingly to the damage and in case its health is now at zero or below it leaves the map.
				
				Note that \texttt{SHOOT\_TO\_ENEMY} is an urgent channel. In other words, a shot to an enemy must be performed in the same time unit where it is "calculated", any other action that "would make the time progress" is "postponed" as long as the turret can fire. We can rephrase this choice by considering time as a resource that enemies need to move and turrets need to shoot. Once a turret is able to shoot, it is not equitable (for our interpretation of the game) that time is "gained" by enemies which delay has not fully elapsed yet. This choice can be also interpreted as the opponent case where a turret needs to wait and an enemy can move. In this situation, time can never pass since it is "blocked" by the combination of invariant and guard in the enemy template, therefore it would not be equitable for turrets if a turret is ready to shoot but enemies (with a delay that still has to elapse) can "ignore" this situation. To implement this concept of "impartiality" we need \texttt{SHOOT\_TO\_ENEMY} to be urgent since the transition fired once the turret delay has expired (i.e. the one with the clock-guard) is not the one that performs the shot (since \texttt{canMove} may not be true by the time the delay expires, this design choice may cause deadlocks), in that case we would have obtained the same effect of an urgent transition.
			\subsubsection{How enemies shoot to the MT}
				Since there is no template for the MT, there is apparently no need to define a channel to "synchronize" the shot since it is nothing more than a decrement of a global variable. However, we still designed an urgent broadcast channel to guarantee that once an enemy can shoot to the MT, time can't elapse (for the same reason why \texttt{SHOOT\_TO\_ENEMY} is urgent). Note that it is necessary to define the channel as broadcast otherwise, since there is no entity that "receives" the message sent over it, a deadlock would happen if an enemy wants to send a message over a non-broadcast channel where no entity is listening on and the time is blocked since the channel is urgent.
		\subsection{Enrichment of Vanilla model with stochastic features}
			To model the stochastic features, there are no big changes from the Vanilla model but they are crucial:
			\begin{itemize}
				\item enemy and turret "speeds" delays : they are no more modeled with a clock but with simple transitions (which guards of course do not involve clocks) and \texttt{rate of exponential} properly set in the locations. For any of these transitions, no other transition can be enabled at the same time in its location, therefore the probability of leaving the location is equal to the probability of taking the transition;
				\item self-loop in \texttt{Dismissed} : it is removed since Uppaal can't determine which transition choose when that self-loop is enabled (if we keep \texttt{Dismissed} without time invariants or rate of exponential, there is no probability that can be used to determine the following state, neither uniform nor exponential). We are not interested in deadlocks for the stochastic version, so we can safely remove it.
			\end{itemize}
			The only delay that is still implemented as a "non-probabilistic" delay is the one related to the spawning time.
			
			Note that there was no change in communication channels since they are already broadcast (stochastic models can only use broadcast channels) and the motivations behind making them \texttt{urgent} are independent of the stochastic nature of the model.
	\section{Verification results}
		\subsection{Vanilla model verification}
			\subsubsection{Verification without turrets}
				To verify the requested properties we wrote the following queries in Uppaal:
				\begin{table}[H]
					\centering
					\begin{tabularx}{\textwidth}{||c|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X||}
						\hline
						 & Verified properties & Result [T/F] & Verification time on Machine 1 [s] & Verification time on Machine 2 [s] & Max. past-waiting list load \\
						\hline
						Q1 & I & T& $\approx$ 9.7 & $\approx$ 5.6& $\approx$ 13100\\ \hline
						Q2 & II & T&  $\approx$ 10.5 & $\approx$ 6.9 & $\approx$ 220\\ \hline
						Q3 & III, IV & T&  $\approx$ 7.3& $\approx$ 4.7 & $\approx$ 14000\\ \hline
						Q4 & V & T&  $\approx$ 6.8& $\approx$ 3.9 & $\approx$ 14000\\
						\hline
					\end{tabularx}
					\caption{Queries without turrets overview}
				\end{table}
				Q1 must verify that the system never reaches a deadlock state, our query is then simply:
				\begin{center}
					$A\square(\lnot deadlock)$
				\end{center}
				Originally, this query aimed only to verify deadlock avoidance as long as the match is not ended (in fact, our model can still verify this query if we remove the self-loop on \texttt{Dismissed}). Informally, we can also argue that no deadlocks can happen even in this way: all enemies will eventually become \texttt{Dismissed} all together, since once all enemies are \texttt{Dismissed} they can start to indefinitely take the self-loop:
				\begin{center}
					$A\lozenge(\forall e \in Enemy\ (e.Dismissed))$
				\end{center}
				
				Q2 aims to verify that all enemies can reach the MT spot:
				\begin{center}
					$A\lozenge(\forall e \in Enemy\ (e.pos==MAIN\_POS))$
				\end{center}
				We interpreted "can reach" as if in any possible path all enemies will eventually reach the MT, this is the reason way this query is not stated with $E\lozenge$.
				
				Another important observation on this formulation is that this query in reality verifies that exists a state in any possible path where all enemies have their position in the MT spot all together. This condition is easy to guarantee in our model since the dismissal of an enemy keeps \texttt{pos} in the last value it had right before the dismissal. It is like we are "freezing" in the \texttt{pos} variable the fact that the enemy reached the MT spot and so by looking at it "eventually" in any path we are sure that all enemies had reached the MT spot.
				
				Q3 verifies both that each circle and each square satisfy the time constraint:
				\begin{center}
					$A\square(\forall e \in Enemy\ ((e.OnTrip \wedge e.pos==MAIN\_POS) \implies (e.trip\_time\leq(MAX\_PATH\_LENGTH*e.speed))))$
				\end{center}
				Simply, once an enemy is \texttt{OnTrip} and reaches the MT spot, it must have satisfied the time constraint for its kind (\texttt{trip\_time} is a classic clock that counts the time units passed from the spawn).
				
				Note that this query would not be satisfied in this form if \texttt{SHOOT\_TO\_MT} was not \texttt{urgent}, since this imposes that time (and so also \texttt{trip\_time}) can't progress as long as the enemy is at the the MT spot in \texttt{OnTrip}.
				
				Q4 is probably the most intuitive query ($shoot\_table[e]$ identifies the record related to the enemy $e$ in the $shoot\_table$):
				\begin{center}
					$A\square(\forall e \in Enemy\ (shoot\_table[e].targetable \implies isRed(e.pos)))$
				\end{center}
				In any state of any possible path, if an enemy is targetable it must be on a red spot.
				
				Note that since \texttt{pos} is by default \texttt{\{0,0\}} before spawning and it is kept at the MT spot once it is reached, even if an enemy is not targetable it will be anyway on a red spot. We put this restriction to the "query scope" anyways because there is no need to check \texttt{pos} if an enemy is not present on the map. 
			\subsubsection{Verification with turrets}
				To verify the requested queries we wrote the following queries in Uppaal:
				
				\begin{table}[H]
					\centering
					\begin{tabularx}{\textwidth}{||c|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X||}
						\hline
						& Verified properties & Result [T/F] & Verification time on Machine 1 [s] & Verification time on Machine 2 [s] & Max. past-waiting list load \\
						\hline
						Q1 & VII & T & $\approx$ 167 & $\approx$ 78 & $\approx$ 50000\\ \hline
						Q5 & VI & T &  $\approx$ 96.8 & $\approx$ 46.5 & $\approx$ 49000  \\
						\hline
					\end{tabularx}
					\caption{Queries with turrets overview}
				\end{table}
				
				Q1 is used also for verifying VII since it ensures the total absence of deadlocks.
				
				Since we defined a "winning" configuration as a configuration that can never let the MT to be defeated, a query that is true if and only if a configuration is winning is:
				\begin{center}
					$A\square(mt\_life>0)$	
				\end{center}
				If the MT is defeated in at least one state of one path, the query will not be satisfied (with the configuration chosen).
				
				Note that in the configurations section we also analyzed the other kinds of "winning" for the chosen configurations. For brevity, we do not report these queries but they are really similar to Q5 (e.g. to verify the weakly-winning property: $E\square(mt\_life>0)$).
		\subsection{Stochastic model verification}
			We verified the property I with two different approaches. The first one is a classical simulation over 100 runs of the property \texttt{mt\_life==MT.health} in 200 time units, while the second one is the analysis of the cumulative probability distribution that MT is eventually damaged in the first 200 time units:
			\begin{figure}[H]
				\centering
				\begin{minipage}{.45\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SIM.png}
					\caption{Simulation of \texttt{mt\_life==MT.health} in the first 200 time units (over 100 runs)}
				\end{minipage}
				\begin{minipage}{.45\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/CPD.png}
					\caption{Cumulative probability distribution that MT is eventually damaged in the first 200 time units (with 1000 runs)}
				\end{minipage}
			\end{figure}
			By simulating the system, we see that in the majority of the runs the MT starts to be damaged around 90 time units and the cumulative probability distribution identifies a mean of $\approx88$ time units.
			
			Also for the property II we wanted to verify it with two complementary approaches. The first one is a classical measurement of the probability that MT's life remains $>0$ in the first 200 time units, while the second one is the calculus of the cumulative probability distribution that MT life is eventually $\leq0$ until the wave has ended (both calculated over 1000 runs). The probability that MT survives in the first 200 time units is $0.633605\pm 0.0303201$ while the cumulative probability distribution that MT is defeated in the first 200 time units is $\approx 0.392$, which is coherent since it is the calculus of the complementary probability that the MT always survives in the first 200 time units.
			
	\section{Analysis of selected configurations}
		\subsection{Vanilla version}
			We further analyzed the default configuration with turrets and four more configurations:
			\begin{figure}[h!]
				\centering
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{configs/vanilla/DownFromCannons.png}
					\caption{\emph{DownFromCannons} configuration}
				\end{minipage}
				\begin{minipage}{.5\textwidth}
					\centering
					\includegraphics[width=\linewidth]{configs/vanilla/DownFromSnipers.png}
					\caption{\emph{DownFromSnipers} configuration}
				\end{minipage}
			\end{figure}
			\begin{figure}[h!]
				\centering
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{configs/vanilla/Cannonphobia.png}
					\caption{\emph{Cannonphobia} configuration}
				\end{minipage}
				\begin{minipage}{.5\textwidth}
					\centering
					\includegraphics[width=\linewidth]{configs/vanilla/Sniperphobia.png}
					\caption{\emph{Sniperphobia} configuration}
				\end{minipage}
			\end{figure}

			First we analyzed if they are winning and of which kind:
			\begin{table}[h!]
				\centering
				\begin{tabularx}{\textwidth}{||X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X||}
					\hline
					& Winning [T/F] & Weakly-winning [T/F] & Strongly-winning [T/F] & Weakly-strongly-winning [T/F] \\
					\hline
					Default 		& T & T & F & T \\ \hline
					DownFromCannons & F & T & F & T \\ \hline
					DownFromSnipers & F & T & F & T \\ \hline
					Cannonphobia 	& T & T & F & T \\ \hline
					Sniperphobia 	& T & T & T & T \\ \hline
				\end{tabularx}
				\caption{Vanilla chosen configurations winning overview}
			\end{table}
			
			Then (mainly to strain more the model and to explore the Uppaal query syntax), we also wanted to define these metrics to evaluate the "strength" of a configuration (we assume that, like in Uppaal, a boolean predicate is evaluated as $1$ if it is \emph{true}, $0$ otherwise):
			\begin{itemize}
				\item \emph{ADMT} (\emph{Average Distance from MT}) : it is the minimum average distance that enemies can have from the MT:
				\begin{center}
					$ADMT:=\min\{\frac{\sum_{e:Enemy} dist(e.pos,MAIN\_POS)}{MAX\_ENEMIES}\}$
				\end{center}
				\item \emph{SE} (\emph{Survived Enemies}) : it is the maximum number of enemies that still were never be killed throughout the whole match:
				\begin{center}
					$SE:=\max\limits_{matchEnded}\{\sum_{e:Enemy} (e.health>0)\}$
				\end{center}
				\item \emph{CUPE} (\emph{Completed Upper Paths Enemies}) : it is the maximum number of enemies that reached the MT by choosing "up" in the junction \{7,4\}:
				\begin{center}
					$CUPE:=\max\{\sum_{e:Enemy} ((e.pos == MAIN\_POS)*(e.chosenPath\neq 2))\}$
				\end{center}
				\item \emph{CLPE} (\emph{Completed Lower Paths Enemies}) : it is the maximum number of enemies that reached the MT by choosing "down" in the junction \{7,4\}:
				\begin{center}
					$CLPE:=\max\{\sum_{e:Enemy} ((e.pos == MAIN\_POS)*(e.chosenPath=2))\}$
				\end{center}
			\end{itemize}
			
			\begin{table}[h!]
				\centering
				\begin{tabular}{||l|c|c|c|c||}
					\hline
					& ADMT & SE & CUPE & CLPE \\
					\hline
					Default 		& 4 & 2 & 2 & 1 \\ \hline
					DownFromCannons & 1 & 5 & 2 & 5 \\ \hline
					DownFromSnipers & 0 & 6 & 2 & 6 \\ \hline
					Cannonphobia 	& 4 & 2 & 2 & 2 \\ \hline
					Sniperphobia 	& 7 & 0 & 0 & 0 \\ \hline
				\end{tabular}
				\caption{Vanilla chosen configurations performances}
			\end{table}
			Note that:
			\begin{itemize}
				\item strongly-winning configurations have a SE of 0 (if an enemy has survived it means that it shot the MT, and so the configuration can't be strongly-winning);
				\item weakly-winning configurations are likely to have a lower ADMT since at least for the execution where the MT is defeated, an amount of enemies arrived at the MT spot and for the same reason, they are likely to have higher SE;
				\item it is quite unlikely to have a configuration where $CUPE>SE$ or $CLPE>SE$, because enemies that reached the MT are really likely to survive (and they will survive of course in configurations like Cannonphobia where the MT spot is outside of any shooting range).
			\end{itemize}
			At the end, to judge a configuration we may look for the one with an higher ADMT and a lower SE. CUPE and CLPE and are not better than SE to compare configurations, we defined them to demonstrate that configurations that do not cover parts of the map are more like to see (from the MT spot point of view) enemies coming from those parts. Indeed, DownFromCannons and DownFromSnipers have $CUPE\leq CLPE$ since they cover more the higher paths of the map, while more "uniform" configurations tend to have $CUPE=CLPE=SE$ (that holds also from a probabilistic point of view; see the section dedicated to the spawn strategy).
		\subsection{Stochastic version}
			In this section, we present the most interesting results we obtained by analyzing the following indexes in the stochastic version of the game:
			\begin{itemize}
				\item SE (Survived Enemies);
				\item \emph{ADT} (Average Death Time) : the average time unit in which killed enemies were killed;
				\item \emph{ADD} (Average Death Distance) : the average distance from MT that killed enemies had when they were killed;
				\item the MT life;
			\end{itemize}
			in four different configurations (Default, DownFromSnipers, Cannonphobia and Sniperphobia). We also analyzed how these parameters change (if they change significantly) when turrets and enemies parameters are changed.
			
			The complete set of plots we generated can be downloaded in EPS (Encapsulated PostScript) and PNG (Portable Network Graphic) formats at \href{https://jmp.sh/0LxAWLjY}{this} shared folder on Jumpshare.
			
			The first interesting result we obtained from the analysis is how the number of survived enemies changes between the configurations:
			\begin{figure}[H]
				\centering
				\begin{minipage}{.45\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SE/OVERVIEW WITH 10 RUNS/SNIPERPHOBIA.png}
					\caption{Sniperphobia SE simulation with 10 runs}
				\end{minipage}
				\begin{minipage}{.45\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SE/OVERVIEW WITH 10 RUNS/DOWNFROMSNIPERS.png}
					\caption{DownFromSnipers SE simulation with 10 runs}
				\end{minipage}
			\end{figure}
			\begin{figure}[h!]
				\centering
				\begin{minipage}{.45\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SE/OVERVIEW WITH 10 RUNS/CANNONPHOBIA.png}
					\caption{Cannonphobia SE simulation with 10 runs}
				\end{minipage}
				\begin{minipage}{.45\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SE/OVERVIEW WITH 10 RUNS/DEFAULT.png}
					\caption{Default SE simulation with 10 runs}
				\end{minipage}
			\end{figure}
			
			Sniperphobia, which was (the only) strongly-winning configuration in the Vanilla version, tends to have a worse SE than the others (even worse than DownFromSnipers which was a weakly-winning configuration).
			However, if we analyze the probability distribution of the SE in first $100$ time units:
			\begin{figure}[H]
				\centering
				\begin{minipage}{.35\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SE/CLOSE-UP WITH TINY WINDOW/SNIPERPHOBIA.png}
					\caption{Sniperphobia SE probability distribution in the first 100 time units with 1000 runs}
				\end{minipage}
				\begin{minipage}{.35\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SE/CLOSE-UP WITH TINY WINDOW/DOWNFROMSNIPERS.png}
					\caption{DownFromSnipers SE probability distribution in the first 100 time units with 1000 runs}
				\end{minipage}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{minipage}{.35\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SE/CLOSE-UP WITH TINY WINDOW/CANNONPHOBIA.png}
					\caption{Cannonphobia SE probability distribution in the first 100 time units with 1000 runs}
				\end{minipage}
				\begin{minipage}{.35\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/SE/CLOSE-UP WITH TINY WINDOW/DEFAULT.png}
					\caption{Default SE probability distribution in the first 100 time units with 1000 runs}
				\end{minipage}
			\end{figure}
			Sniperphobia tends to have a slightly better average value (for SE, the lower the better) than the other configurations and DownFromSnipers is by far the worst one.
			
			Our explanation of this phenomena is that with a large amount of enemies, turrets with higher delays (i.e. snipers respect to cannons) generally tend to have the worse performances. In fact, if we take the delay of snipers down of 7, Sniperphobia outclasses any other configuration:
			\begin{figure}[H]
				\centering
				\includegraphics[width=.5\textwidth]{plots/SE/OVERVIEW WITH DELAY 7 SNIPERS/SNIPERPHOBIA.png}
				\caption{Sniperphobia SE simulation with 10 runs (snipers delay set to 7)}
			\end{figure}
			
			Here we see how stochastic model checking can reveal behaviors that with exhaustive model checking would have been too computationally complex to verify. With stochastic model checking, we were able to show that in larger waves, a turret with a lower damage but a lower firing speed tends to provide better performances over turrets with higher damages and higher speeds.
			
			While analysis of ADT and MT life have not really shown surprising results respect to the ones shown with the analysis of the SE (MT life tends to get lower as SE increases since survived enemies have also shot the MT and it is quite predictable that configurations with higher firing speeds tends to have higher ADT), a curious result came from the analysis of the ADD, in particular:
			\begin{figure}[H]
				\centering
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/ADD/PD/SNIPERPHOBIA.png}
					\caption{Sniperphobia ADD probability distribution in the first 100 time units with 500 runs}
				\end{minipage}
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/ADD/PD/DOWNFROMSNIPERS.png}
					\caption{DownFromSnipers ADD probability distribution in the first 100 time units with 500 runs}
				\end{minipage}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/ADD/PD/CANNONPHOBIA.png}
					\caption{Cannonphobia ADD probability distribution in the first 100 time units with 500 runs}
				\end{minipage}
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/ADD/PD/DEFAULT.png}
					\caption{Default ADD probability distribution in the first 100 time units with 500 runs}
				\end{minipage}
			\end{figure}
			Sniperphobia tends to kill enemies in a slightly greater distance from the MT spot and with more "uniform" probability distribution.
			
			Finally, we simulated the system in what we called the \emph{Over Range mode}: any turret has a range of 15 (i.e. any turret may fire enemies in any point of the map). We may think that this parameter choice tends to uniform the performances between configurations or tends to let snipers outclass cannons and basics however, no index changed significantly its trend. The only notable change we found is that the hyperbolic trend of ADD tends to have an higher product rather than just an higher asymptotic value:
			\begin{figure}[H]
				\centering
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/ADD/OVERVIEW WITH 10 RUNS/CANNONPHOBIA.png}
					\caption{Cannonphobia ADD simulation with 10 runs}
				\end{minipage}
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/ADD/OVERVIEW WITH OVER RANGE/CANNONPHOBIA.png}
					\caption{Cannonphobia ADD simulation with 10 runs (in over range mode)}
				\end{minipage}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/ADD/OVERVIEW WITH 10 RUNS/DEFAULT.png}
					\caption{Default ADD simulation with 10 runs}
				\end{minipage}
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=\linewidth]{plots/ADD/OVERVIEW WITH OVER RANGE/DEFAULT.png}
					\caption{Default ADD simulation with 10 runs (in over range mode)}
				\end{minipage}
			\end{figure}
	\section{Conclusions}
		We modeled UppaalTD in both Vanilla and Stochastic version and verified relevant properties on it. Moreover, we defined metrics to evaluate and compare different configurations in Vanilla version and demonstrated with a small amount of selected configurations that winning and strongly-winning configurations tend to have higher performances w.r.t. them. Finally, we analyzed how these (and other) indexes evolve in stochastic simulations in order to identify more general behaviors of the model and we tried to reason on the behaviors we observed.
	\newpage
	\appendix
	\section{Discarded choices}
		Even if our final design choices are what we believed to be more efficient and adequate for our interpretation of the game, some of the discarded ones may possibly be more adequate in other contexts or with different requirements so, we positively considered their mention in the report.
		\subsection{MT template}
			Originally, a template for MT was designed. It was, for its simplicity, the very first one to be designed (\texttt{decDamage} decreases MT's life by the value set in a global variable from the firing enemy):
			
			\begin{figure}[h!]
				\centering
				\includegraphics[width=0.5\textwidth]{MT_Template.png}
				\caption{Original MT's template}
			\end{figure}
		\subsection{Hard-coded enemies paths}
			The very first enemy version used the concept of \texttt{next} but there was no idea on how to model the non-deterministic moves (unless using the built-in function \texttt{random}, which is not available in symbolic simulation). The only idea we came up with was to hard-code vectors of cells representing each straight red path on the map and enemies template would have chosen between them non-deterministically with transitions (once an enemy arrives in the last cell of a path, then it will start to follow non-deterministically one of the "next paths"):
			
			\begin{figure}[h!]
				\centering
				\includegraphics[width=0.65\textwidth]{ENEMIES_PATHS.png}
				\caption{Original non-deterministic path choices example}
			\end{figure}
		\subsection{Quadratic enemies scanning strategy}
			The very first turret version used to look for enemies to shoot in this way: for each $k$ from $1$ to \texttt{range}, scan \texttt{SHOOT\_TABLE} to find all the available enemies at exactly $k$ cells of distance; then, choose the best iso-distant available enemy based on the requirements criteria. The worst-case asymptotic complexity of this procedure was linear in $k\times MAX\_ENEMIES$ which provided significantly worse performances than our final implementation of the scan, which is linear in $MAX\_ENEMIES$.
		\subsection{Locks}
			At the beginning, the first way of synchronizing entities was thought in a classical lock-unlock manner:
			\begin{figure}[h!]
				\centering
				\begin{minipage}{.5\textwidth}
					\centering
					\includegraphics[width=.9\linewidth]{enemyLock.png}
					\caption{Close-up of the enemy locking \texttt{STMT} channel}
				\end{minipage}
				\begin{minipage}{.4\textwidth}
					\centering
					\includegraphics[width=.9\linewidth]{controller.png}
					\caption{\texttt{STMTCONTROLLER} template}
				\end{minipage}
			\end{figure}
			Once an enemy had reached the MT (for the MT template please see the proper section of the appendix):
			\begin{enumerate}
				\item the enemy would have sent a message to \texttt{STMTCONTROLLER} and have waited for its reply (more precisely, Uppaal chooses non-deterministically which one of the ready enemies can send the message to the controller);
				\item once the controller had replied the enemy would have placed in the shared variable the damage for the MT;
				\item the enemy would have shot to the MT (i.e. sending of a message over \texttt{STMT});
				\item the enemy would have sent a message to \texttt{STMTCONTROLLER} to release the "lock".
			\end{enumerate}
			We understand that this solution is:
			\begin{itemize}
				\item deadlock-free: soon or later an acquired lock will be released and soon or later a lock request will be accepted;
				\item not starvation-free: since it is not guaranteed that any enemy that requests a lock will eventually obtain it.
			\end{itemize}
			We removed this concept since we understood that a single transition that both changes the global variable and performs the shoot would have produced the same behavior, since, provided that this transition is not synchronized with other enemies, only one of them can perform it at a time (even in the same time unit, only one of them can be executed at a time), therefore there is no possibility that an enemy places the damage for the MT into the shared variable and before sending the shooting message another enemy changes the variable and (or not) shoots to the MT (which would clearly generate an undesired behavior).
		\subsection{Lifetime counter}
			Turrets understand that an enemy is present on the map for a shorter amount of time by looking to its spawning time however, this idea is relatively new in the history of the model, since at the beginning, the lifetime of an enemy used to be an \texttt{int} variable (not a clock, since in symbolic simulation clocks be read, by turrets, as \texttt{double} values) updated in each time unit by the enemy:
			
			\begin{figure}[h!]
				\centering
				\includegraphics[width=0.5\textwidth]{lifetimeCounter.png}
				\caption{Close-up of of the lifetime counter of an enemy}
			\end{figure}
			With clock \texttt{z}, at each time unit the lifetime counter would have been updated.
			
			Before introducing the \texttt{trip\_time} clock, this solution was also used to verify that enemies would have reached the MT spot in no more than $\texttt{MAX\_PATH\_LENGTH}\times speed$ time units.
	\nocite{1,2,3,4,5,6,7,8}
	\printbibliography
\end{document}